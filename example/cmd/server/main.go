package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"

	"{{.Module}}/internal/api"
	"{{.Module}}/internal/middleware"
	"{{.Module}}/internal/pkg/config"
	"{{.Module}}/internal/pkg/logger"
	"{{.Module}}/internal/pkg/types"

	// "{{.Module}}/docs"
	// _ "{{.Module}}/docs" // swagger docs

	"github.com/gofiber/fiber/v2"
)

//	@title			my-api API
//	@version		1.0
//	@description	A Go API built with Fiber and Wire
//	@description	Generated using taskw - Go API Code Generator
//	@termsOfService	http://swagger.io/terms/

//	@contact.name	API Support
//	@contact.url	http://www.example.com/support
//	@contact.email	support@example.com

//	@license.name	MIT
//	@license.url	https://opensource.org/licenses/MIT

//	@host		localhost:3000

//	@securityDefinitions.basic	BasicAuth

//	@externalDocs.description	OpenAPI
//	@externalDocs.url			https://swagger.io/resources/open-api/

func main() {
	fmt.Println("Starting hello-taskw API...")
	fmt.Println("This project requires taskw to generate routes and dependencies")

	// Get environment info
	env := os.Getenv("ENV")
	if env == "" {
		env = "dev"
	}
	fmt.Printf("Environment: %s\n", env)

	// Get config info
	cfg := config.GetConfig()
	if cfg != nil {
		fmt.Printf("App: %s v%s\n", cfg.App.Name, cfg.App.Version)
		fmt.Printf("Database: %s\n", cfg.DB.Driver)
		fmt.Printf("Debug mode: %t\n", cfg.App.Debug)
		fmt.Printf("Log level: %s\n", cfg.App.LogLevel)
	}

	// Use Wire-generated dependency injection container
	fmt.Println("Initializing dependency injection container...")
	router, err := api.InitializeRouter()
	if err != nil {
		log.Fatalf("❌ Failed to initialize server: %v\n\nDid you run 'taskw generate' to create the required code?", err)
	}

	fmt.Println("✅ Server initialized successfully (taskw-generated code is working!)")

	// Get app instance from router
	app := router.GetApp()
	fmt.Println("Fiber app instance obtained")

	// Setup middleware
	fmt.Println("Setting up middleware...")
	setupMiddleware(app, router)
	fmt.Println("✅ Middleware setup completed")

	// Setup routes (this will use taskw-generated route registration)
	fmt.Println("Setting up routes...")
	setupRoutes(app, router)
	fmt.Println("✅ Routes setup completed")

	// Start server with graceful shutdown
	startServer(app, router)
}

// setupMiddleware configures global middleware
func setupMiddleware(app *fiber.App, _ *api.Router) {
	fmt.Println("  Adding Recovery middleware...")
	app.Use(middleware.RecoveryMiddleware())

	fmt.Println("  Adding CORS middleware...")
	app.Use(middleware.CORS())

	// core middleware
	fmt.Println("  Adding Trace middleware...")
	app.Use(middleware.TraceMiddleware()) // trace_id

	fmt.Println("  Adding Response middleware...")
	app.Use(middleware.ResponseMiddleware()) // unified JSON response

	fmt.Println("  Adding Validator middleware...")
	app.Use(middleware.ValidatorMiddleware()) // request validation

	fmt.Println("  Creating development logger...")
	devLogger := logger.NewDevelopmentLogger()
	fmt.Println("  Adding Logger middleware...")
	app.Use(middleware.LoggerMiddleware(devLogger))
}

// setupRoutes registers routes and Swagger documentation
func setupRoutes(app *fiber.App, router *api.Router) {

	// Scalar documentation
	scalarConfig := middleware.DefaultScalarConfig()
	scalarConfig.Title = "my-api API Documentation"
	scalarConfig.Description = "A Go API built with Fiber and Wire - Generated using taskw"
	scalarConfig.Version = "1.0"
	middleware.SetupScalarRoutes(app, scalarConfig)

	// API routes - this uses taskw-generated route registration
	fmt.Println("Registering API routes (generated by taskw)...")
	router.RegisterHandlers()

	// // Print all registered routes
	// fmt.Println("Registered routes:")
	// routes := app.GetRoutes(false)
	// apiRoutes := 0
	// for _, route := range routes {
	// 	if route.Path != "/" && route.Path != "/health" {
	// 		fmt.Printf("  %s %s\n", route.Method, route.Path)
	// 		apiRoutes++
	// 	}
	// }
	// fmt.Printf("Total API routes registered: %d\n", apiRoutes)

	// 404 handler
	app.Use(func(c *fiber.Ctx) error {
		response := types.Response{
			Code: 1,
			Msg:  fmt.Sprintf("Route '%s' not found", c.Path()),
			Data: nil,
		}
		return c.JSON(response)
	})
}

// startServer starts HTTP service
func startServer(app *fiber.App, _ *api.Router) {
	// Channel to listen for interrupt signal
	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)

	// Start server in a goroutine
	go func() {
		// get port from config, prioritize environment variable
		port := "3000"
		if envPort := os.Getenv("PORT"); envPort != "" {
			port = envPort
		} else {
			// get port from config singleton
			cfg := config.GetConfig()
			if cfg != nil && cfg.Server.Port > 0 {
				port = fmt.Sprintf("%d", cfg.Server.Port)
			}
		}

		fmt.Printf("Server starting on port %s\n", port)
		fmt.Printf("API Documentation:\n")
		fmt.Printf("   Scalar:  http://localhost:%s/docs\n", port)
		fmt.Printf("   Health:  http://localhost:%s/health\n", port)
		fmt.Printf("   API Base: http://localhost:%s/api/\n", port)
		fmt.Println("")
		fmt.Println("✅ Ready to accept requests!")
		fmt.Println("")

		if err := app.Listen(":" + port); err != nil {
			log.Fatalf("❌ Error starting server: %v", err)
		}
	}()

	// Wait for interrupt signal
	<-c
	fmt.Println("Received shutdown signal...")
	fmt.Println("Gracefully shutting down...")

	// Create a deadline for shutdown
	_, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// Shutdown the server
	if err := app.Shutdown(); err != nil {
		log.Printf("❌ Server forced to shutdown: %v", err)
	}

	fmt.Println("✅ Server shutdown complete")
}
